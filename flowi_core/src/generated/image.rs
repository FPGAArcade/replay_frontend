// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::manual::{get_last_error, Color, FlData, FlString, Result};

#[allow(unused_imports)]
use bitflags::bitflags;

#[allow(unused_imports)]
use crate::math_data::*;

#[repr(C)]
pub struct ImageFfiApi {
    pub(crate) data: *const core::ffi::c_void,
    pub(crate) load: unsafe extern "C" fn(data: *const core::ffi::c_void, url: FlString) -> u64,
    pub(crate) load_with_options: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        url: FlString,
        options: *const ImageOptions,
    ) -> u64,
    pub(crate) get_status:
        unsafe extern "C" fn(data: *const core::ffi::c_void, image: u64) -> ImageLoadStatus,
    pub(crate) get_info:
        unsafe extern "C" fn(data: *const core::ffi::c_void, image: u64) -> *const ImageInfo,
    pub(crate) get_data: unsafe extern "C" fn(data: *const core::ffi::c_void, image: u64) -> FlData,
}

#[cfg(feature = "static")]
extern "C" {
    pub fn fl_image_load_impl(data: *const core::ffi::c_void, url: FlString) -> u64;
    pub fn fl_image_load_with_options_impl(
        data: *const core::ffi::c_void,
        url: FlString,
        options: *const ImageOptions,
    ) -> u64;
    pub fn fl_image_get_status_impl(data: *const core::ffi::c_void, image: u64) -> ImageLoadStatus;
    pub fn fl_image_get_info_impl(data: *const core::ffi::c_void, image: u64) -> *const ImageInfo;
    pub fn fl_image_get_data_impl(data: *const core::ffi::c_void, image: u64) -> FlData;
}

#[no_mangle]
pub static mut g_flowi_image_api: *const ImageFfiApi = std::ptr::null_mut();

#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum ImageFormat {
    /// 8-bit per channel Red, Green and Blue
    Rgb = 0,
    /// 8-bit per channel Red, Green, Blue and Alpha
    Rgba = 1,
    /// 8-bit per channel Blue, Green and Red
    Bgr = 2,
    /// 8-bit per channel Blue, Green and Red and Alpha
    Bgra = 3,
    /// 8-bit per channel Alpha only
    Alpha = 4,
}

#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum ImageLoadStatus {
    /// The image is still loading
    Loading = 0,
    /// The image has finished loading
    Loaded = 1,
    /// The image failed to load
    Failed = 2,
}

#[repr(C)]
#[derive(Debug)]
pub struct ImageInfo {
    /// Format of the image. See the ImageFormat enum
    pub format: u32,
    /// width of the image
    pub width: u32,
    /// height of the Image
    pub height: u32,
    /// Number of frames. This is 1 for static images and > 1 for animated images
    pub frame_count: u32,
    /// How long each frame should be displayed for in milliseconds
    pub frame_delay: u32,
}

#[repr(C)]
#[derive(Debug, Copy, Clone, Default)]
pub struct ImageOptions {
    /// The scale of the image. This is useful for loading SVGs at different sizes.
    pub scale: Vec2,
    /// Set a size of the image (this will override the scale). if one component is set to 0 it will be calculated based on the aspect ratio of the image.
    pub size: Vec2,
}

unsafe impl bytemuck::Pod for ImageOptions {}
unsafe impl bytemuck::Zeroable for ImageOptions {}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image {
    pub handle: u64,
}

impl Image {
    /// Async Load image from url/file. Supported formats are: JPG, PNG, SVG and GIF
    /// Notice that this will return a async handle so the data may not be acceassable directly.
    pub fn load(url: &str) -> Image {
        unsafe {
            let _api = &*g_flowi_image_api;
            #[cfg(feature = "static")]
            let ret_val = fl_image_load_impl(_api.data, FlString::new(url));
            #[cfg(any(feature = "dynamic", feature = "plugin"))]
            let ret_val = (_api.load)(_api.data, FlString::new(url));
            Image { handle: ret_val }
        }
    }

    /// Async Load image from url/file. Supported formats are: JPG, PNG, SVG and GIF
    /// Notice that this will return a async handle so the data may not be acceassable directly.
    pub fn load_with_options(url: &str, options: &ImageOptions) -> Image {
        unsafe {
            let _api = &*g_flowi_image_api;
            #[cfg(feature = "static")]
            let ret_val =
                fl_image_load_with_options_impl(_api.data, FlString::new(url), options as _);
            #[cfg(any(feature = "dynamic", feature = "plugin"))]
            let ret_val = (_api.load_with_options)(_api.data, FlString::new(url), options as _);
            Image { handle: ret_val }
        }
    }

    /// Get the status of the image. See the [ImageLoadStatus] enum
    pub fn get_status(image: Image) -> ImageLoadStatus {
        unsafe {
            let _api = &*g_flowi_image_api;
            #[cfg(feature = "static")]
            let ret_val = fl_image_get_status_impl(_api.data, image.handle);
            #[cfg(any(feature = "dynamic", feature = "plugin"))]
            let ret_val = (_api.get_status)(_api.data, image.handle);
            ret_val
        }
    }

    /// Get info about the image. Will be null if the image hasn't loaded yet or failed to load.
    pub fn get_info<'a>(image: Image) -> Result<&'a ImageInfo> {
        unsafe {
            let _api = &*g_flowi_image_api;
            #[cfg(feature = "static")]
            let ret_val = fl_image_get_info_impl(_api.data, image.handle);
            #[cfg(any(feature = "dynamic", feature = "plugin"))]
            let ret_val = (_api.get_info)(_api.data, image.handle);
            if ret_val.is_null() {
                Err(get_last_error())
            } else {
                Ok(&*ret_val)
            }
        }
    }

    /// Get data from the image. Will be null if the image hasn't loaded yet or failed to load.
    pub fn get_data<'a>(image: Image) -> Option<&'a [u8]> {
        unsafe {
            let _api = &*g_flowi_image_api;
            #[cfg(feature = "static")]
            let ret_val = fl_image_get_data_impl(_api.data, image.handle);
            #[cfg(any(feature = "dynamic", feature = "plugin"))]
            let ret_val = (_api.get_data)(_api.data, image.handle);
            if ret_val.data == std::ptr::null() {
                None
            } else {
                Some(std::slice::from_raw_parts(
                    ret_val.data as *const u8,
                    ret_val.size as _,
                ))
            }
        }
    }
}
